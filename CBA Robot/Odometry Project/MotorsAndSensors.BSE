' ==============================================================================
'
'   File...... MotorsAndSensors.BSE
'   Purpose... Motor and sensor module for multi-bank programs
'   Author.... Martin Heermance
'   E-mail.... mheermance@gmail.com
'   Started... 2010 April
'   Updated... 2011 February 21th
'
'   {$STAMP BS2e}
'   {$PBASIC 2.5}
'
' ==============================================================================


' ------------------------------------------------------------------------------
' Program Description
' ------------------------------------------------------------------------------


' ------------------------------------------------------------------------------
' Revision History
' ------------------------------------------------------------------------------
' 2010-05-02 removed unused constants.
' 2010-05-03 pulled magic numbers out of code to become constants.
' 2010-05-08 wrote a draft of motor control code.
' 2010-05-15 unit tested motor control code and pulled common code into functions.
' 2010-05-22 added stop function and began adding bar code reading.
' 2010-07-04 added check stall stub and ability to ping during a move.
' 2010-07-11 switched to brads as unit of angular measure to save RAM.
' 2011-02-15 moved half finished code to end, added calibration to Hm55b,
'            changed motor routines to borrow ideas from Phil Pilgram.
' 2011-02-21 Borrowed Phil's ramping code as it was better than mine.
' 2011-02-26 Move gripper code to its own module and added MoveXY.
' 2011-02-27 Changed HeadAngle to PingAngle and swapped the sign to polar style.

' ------------------------------------------------------------------------------
' I/O Definitions
' ------------------------------------------------------------------------------

LMFIN           PIN     0                     ' Pin for reading LFM
LCD             PIN     1                     ' LCD output
' Pins 1-5 (6 is optional) are LFM LED control PINS
DinDout         PIN     7                     ' Pin for serial data in/out
Clock           PIN     9                     ' Pin for serial I/O clock pulses
CompassEn       PIN     8                     ' Pin for HM55B's /EN(ABLE)
Ping            PIN     10                    ' Pin for PING))) Sensor
PingServo       PIN     11                    ' Pin for PING))) Servo
RMotor          PIN     12                    ' Pin for right servo
LMotor          PIN     13                    ' Pin for left servo
LEncoder        PIN     15                    ' Pin for left wheel encoder
REncoder        PIN     14                    ' Pin for right wheel encoder

' ------------------------------------------------------------------------------
' Constants
' ------------------------------------------------------------------------------

'--------[Calibration Constants, must be adjusted for your specific robot]------

'
' Adjust FULLROT for best precision on a closed course.
' Recompute BRDSPER as shown.
'

FULLROT     CON         $3C39
BRDSPER     CON         $0440

' Servo velocity calibration data generated by Phil's program.

DATA @0, 7,11,16,20,26,32,42,47
DATA     52,56,61,66,72,77,82,87
DATA     7,12,18,23,29,36,43,49
DATA     55,61,65,70,75,80,84,89
DATA     4,9,13,18,24,33,40,45
DATA     50,55,59,65,70,75,81,86
DATA     11,16,21,29,36,42,48,54
DATA     59,65,71,76,82,88,93,99

' Compass Calibration Data generated by calibration program by unknown.

CompassOffsets  DATA Word -12, Word -7        ' X and Y axis offsets
CompassLowVal   DATA 0                        ' Stores index of lowest angle
CompassCal      DATA 2,22,35,51,68,82,97,123, ' 16 reference compass angles
                     130,157,169,180,193,208,224,242

PingCenter      CON     645                   ' head servo center

'---------[Other Global Constants]----------------------------------------------

#SELECT $STAMP
  #CASE BS2, BS2E
    NULL        CON     750                   ' Pulse width for 1.5ms stop pulse.
    Trigger     CON     5                     ' trigger pulse = 10 uS
    Scale       CON     $200                  ' raw x 2.00 = uS
  #CASE BS2SX, BS2P, BS2PX
    MStop       CON     1875                  ' Pulse width for 1.5ms stop pulse.
    Trigger     CON     13
    Scale       CON     $0CD                  ' raw x 0.80 = uS
  #CASE BS2PE
    NULL        CON     1875                  ' Pulse width for 1.5ms stop pulse.
    Trigger     CON     5
    Scale       CON     $1E1                  ' raw x 1.88 = uS
#ENDSELECT

RawToIn         CON     889                   ' 1 / 73.746 (with **)
RawToCm         CON     2257                  ' 1 / 29.034 (with **)

IsHigh          CON     1                     ' for PULSOUT
IsLow           CON     0

Reset           CON     %0000                 ' Reset command for HM55B
Measure         CON     %1000                 ' Start measurement command
Report          CON     %1100                 ' Get status/axis values command
Ready           CON     %1100                 ' 11 -> Done, 00 -> no errors
NegMask11       CON     $F800                 ' For 11-bit negative to 16-bits
NegMask8        CON     $FF00                 ' For 8-bit negative to 16-bits

LEDon           CON     0                     ' Constant to turn LED on
LEDoff          CON     1                     ' Constant to turn LED off

Success         CON     0                     ' Constant for zero success
ErrorStall      CON     -1                    ' Constant for closer than min
ErrorTooClose   CON     -2                    ' Constant for farther than max
ErrorTooFar     CON     -3                    ' Constant to turn LED off

RIGHT           CON     0                     ' Subscripts into bit arrays.
LEFT            CON     1

Sense           CON     REncoder              ' Base address for encoders.
Motor           CON     RMotor                ' Base address for motors.

XPOS            CON     0
YPOS            CON     1
COM_SPEED       CON     84                    ' 9600 baudnon-inverted.

' ------------------------------------------------------------------------------
' Variables - for simplicty I use exactly the same variables in all modules.
' ------------------------------------------------------------------------------

' General purpose volatile variables which are modified by subroutines or tasks

' ACC is an accumulator, branch offset, and task dispatch register
ACC             VAR     Word
Task            VAR     ACC.LOWBYTE           ' Alias for task dispatching
TaskBank        VAR     Task.HIGHNIB          ' Alias to access bank
TaskIndex       VAR     Task.LOWNIB           ' Alias to access index

' Loop index variables and for argument passing.
X               VAR     Word
Y               VAR     Word
Z               VAR     Word
MinDistance     VAR     Z.LOWBYTE             ' Alias for distance constraint.
MaxDistance     VAR     Z.HIGHBYTE            ' Alias for distance constraint.

' State variables which are modified to reflect changes of robot state.
SP              VAR     Byte                  ' Scratch pad pointer
Prev            VAR     Bit(2)                ' Previous readings from encoders.
New             VAR     Bit(2)                ' Current readings from encoders.
Dir             VAR     Bit(2)                ' Wheel directions (FWD or BAK).
Side            VAR     Bit                   ' Side index (RIGHT or LEFT).
Opp             VAR     Bit                   ' Index to the other side (saves code).
Dist            VAR     Byte(2)               ' Distance for each wheel to travel.
Counts          VAR     Byte(2)               ' Encoder pulse countdown for each wheel.
DirErr          VAR     Word                  ' Current directional error in brads and 1/256 brads.
Heading         VAR     Byte                  ' Robot compass heading
Theta           VAR     Byte                  ' Computed Heading
PingAngle       VAR     Byte                  ' Ping servo compass angle in brads
Position        VAR     Byte(2)               ' X, Y position of robot.

' Alias to allow imported code to compile.
Pulse           VAR     ACC.LOWBYTE           ' Current unscaled, unnulled servo pulse value.
Arg             VAR     Y.LOWBYTE             ' Requested travel or turn amount.
Veloc           VAR     Y.HIGHBYTE.LOWNIB     ' Requested maximum velocity.

' ------------------------------------------------------------------------------
' EEPROM Data
' ------------------------------------------------------------------------------


' ------------------------------------------------------------------------------
' Initialization
' ------------------------------------------------------------------------------

ModuleEntry:
  DEBUG "Sensor entry point, TaskIndex = ", DEC TaskIndex, " SP = ", DEC SP, CR
  ' Save any variables on scratchpad here.
  ON TaskIndex GOSUB Initialize, ReadLFM, ReadBarcode,
                     PingDistance, PingAngleSet, PingSweep,
                     Move, MoveXY,
                     Turn, TurnCompass, TurnRight, TurnLeft,
                     StopIt

  ' Restore variables here.
  DEBUG "Return from gosub SP = ", DEC SP, CR
  SP = SP - 1                                 ' Pull the Task off and return.
  GET SP, Task
  DEBUG "Sensor exit point, X=", DEC X, " Task=", HEX Task, " SP=", DEC SP, CR
  RUN TaskBank

' ------------------------------------------------------------------------------
' Program Code
' ------------------------------------------------------------------------------


' ------------------------------------------------------------------------------
' Subroutines
' ------------------------------------------------------------------------------

Initialize:
  OUTL = %01111110                            ' Set all six of the sensor LEDs to off.
  DIRL = %01111110                            ' Set all six of the LED Stamps pins to outputs.

  Prev(LEFT) = LEncoder                       ' Preset values for the last reading
  Prev(RIGHT) = REncoder                      ' equal to the resting value.
  GOSUB StopIt                                ' Tell both servos to stop to prevent initial lurch
  PingAngle = 0                               ' Center the Ping servo.
  GOSUB PingAngleSet
  GOSUB ReadCompass                           ' Get initial robot heading
  RETURN

' ReadLFM - reads the line following module and returns the bits in X.
' Inputs:
' Outputs:
'   X - bits of LFM readings low bit is right most sensor.
ReadLFM:
  X = 0                                       ' Clear the last reading
  FOR Y = 1 TO 6                              ' Loop through each of the six sensors
    OUTL.LOWBIT(Y) = LEDon                    ' Turn on the LED for sensor to be checked
    PAUSE 1                                   ' Pause for the detector to respond
    X.LOWBIT(Y) = IN0                         ' Read the value of the comparitor into it's bit position.
    OUTL = OUTL | %01111110                   ' Turn off any of the LEDs that may have been turned on
  NEXT
  X = X >> 1                                  ' Shift the bits to the right one because we didn't use P0
  RETURN

' PingDistance - reads the distance at the current head angle.
' Inputs:
' Outputs:
'   X - distance in inches.
PingDistance:
  Ping = IsLow                                ' make trigger 0-1-0
  PULSOUT Ping, Trigger                       ' activate sensor
  PULSIN  Ping, IsHigh, X                     ' measure echo pulse
  X = X */ Scale                              ' convert to uS
  X = X / 2                                   ' remove return trip
  X = X ** RawToIn                            ' convert to inches
  RETURN

' PingAngle - sets the ping servo to the input signed brad offset
'   relative to front using polar coordinate convention.
' Inputs:
'   HeadAngle
' Outputs:
PingAngleSet:
  ACC = PingAngle
  GOSUB SignExtendAcc
  ACC = PingCenter + (6 * ACC)
  FOR X = 1 TO 25
    PULSOUT PingServo, ACC
    PAUSE 20
  NEXT
  RETURN

' PingSweep - sets the servo to five different angles and returns the distances.
' Inputs:
' Outputs:
'   five words in the scratch pad ram.
PingSweep:
  FOR Y = 0 TO 4
    LOOKUP Y, [64, 32, -32, -64, 0], PingAngle
    GOSUB PingAngleSet
    GOSUB PingDistance
    PUT SP, Word X                            ' Place results in scratch pad.
    SP = SP + 2
  NEXT
  SP = SP - 10                                ' Restore SP for return. Consumer will know to pickup values.
  RETURN

' ReadCompass - this subroutine handles BASIC Stamp - HM55B communication
' and stores the heading adjusted by the head postion and calibration
' constants. It uses the scratchpad so it only changes Heading.
' Inputs:
' Outputs:
'   Heading
ReadCompass:
  ' Put ACC, X, Y, and Z on the scratch pad.
  PUT SP, Word ACC
  PUT SP+2, Word X
  PUT SP+4, Word Y
  PUT SP+6, Word Z

  ' Get the X and Y compass axis
  HIGH CompassEn: LOW CompassEn               ' Send reset command to HM55B
  SHIFTOUT DinDout, Clock, MSBFIRST, [Reset\4]
  HIGH CompassEn: LOW CompassEn               ' HM55B start measurement command
  SHIFTOUT DinDout, Clock, MSBFIRST, [Measure\4]
  ACC = 0                                     ' Clear previous status flags

  DO                                          ' Status flag checking loop
    HIGH CompassEn: LOW CompassEn             ' Measurement status command
    SHIFTOUT DinDout, Clock, MSBFIRST, [Report\4]
    SHIFTIN  DinDout, Clock, MSBPOST, [ACC\4] ' Get Status
  LOOP UNTIL ACC = Ready                      ' Exit loop when status is ready

  SHIFTIN  DinDout,Clock,MSBPOST,[x\11,y\11]  ' Get x & y axis values
  HIGH CompassEn                              ' Disable module

  IF (Y.BIT10 = 1) THEN
    Y = Y | NegMask11                         ' Store 11-bits as signed word
  ENDIF
  IF (X.BIT10 = 1) THEN
    X = X | NegMask11                         ' Repeat for other axis
  ENDIF

  ' Correct the cumulative magnetic field interference that can come
  ' from sources such as the PCB, jumper wires, a nearby battery, or
  ' current source.  This code relies on values stored in the EEPROM
  ' that was reserved by the CompassOffsets DATA directive.

  READ CompassOffsets, Word Z                 ' Get x-axis offset
  X = X - Z                                   ' Correct x-axis
  READ CompassOffsets + 2, Word Z             ' Get y-axis offset
  Y = Y - Z                                   ' Correct y-axis

  Heading = X ATN - Y                         ' Convert X and Y To brads
  Heading = Heading - PingAngle               ' Adjust for PING servo angle

  ' Apply linear interpolation to the refine the compass measurement.
  ' This corrects axis skew and other errors inherent to the HM55B chip.
  ' It relies on sixteen actual compass measurements stored in the EEPROM.

  ' Alias variables to make compass code more readable
  span            VAR     X                   ' Span between table entries
  angleOffset     VAR     Y                   ' Offset btwn measured and table
  Previous        VAR     Z.LOWBYTE
  Current         VAR     Z.HIGHBYTE

  ' Start with the lowest value in the CompassCal table.

  READ CompassLowVal, ACC

  ' Load current and previous table values.

  READ CompassCal + ACC, Current
  READ (CompassCal + (ACC - 1 & $F)), Previous

  ' The IF...ELSEIF...ELSE...ENDIF code block finds the two EEPROM CompassCal
  ' table values that the current angle measurement falls between and calculates
  ' the difference between the current angle measurement and the lower of the
  ' two table values.  The IF and ELSEIF blocks deal with values that are
  ' greater than the highest or less than the lowest table values.  The ELSE
  ' block everything between the highest and lowest table values.

  IF (Heading >= Previous) THEN
    span = (255 - Previous) + Current
    angleOffset = Heading - Previous
  ELSEIF (Heading <= Current) THEN
    span = Current + (255 - Previous)
    angleOffset = Heading + (255 - Previous)
  ELSE
    ACC = ACC - 1
    READ CompassCal + ACC, Current
    DO
      Previous = Current
      ACC = ACC + 1
      READ CompassCal + ACC, Current
      IF (Heading <= Current) AND (Heading > Previous) THEN
        span = Current - Previous
        angleOffset = Heading - Previous
        EXIT
      ENDIF
    LOOP
  ENDIF

  ' After the offset between the current angle measurement and the next lower
  ' table measurement has been determined, this code block uses it along with
  ' the span between the table entries above and below the angle measurement
  ' to solve for: angle(corrected) = angle(offset) * 16 / span.
  ' This code block also rounds up or down by comparing the remainder of
  ' the angleOffset / span division to the value of (span / 2).

  angleOffset = angleOffset * 16
  Z = (angleOffset / span) + ((angleOffset // span) / (span / 2))
  Z = ((ACC - 1 & $F) * 16) + Z
  Heading = Z & $ff

  ' Restore from scratch pad space.
  GET SP+6, Word Z
  GET SP+4, Word Y
  GET SP+2, Word X
  GET SP, Word ACC
  RETURN

' Move - moves the robot forward or backward a signed quantity
' Inputs:
'   ARG (Y.LOWBYTE) - signed number of ep units to move (roughly .5").
'   Veloc (Y.HIGHBYTE) - unsigned speed where 0 is stopped to 15 fast.
'   Z - distance constraint (low byte min, top byte max) zero = none.
' Outputs:
'   X - 0 success, -1 stall, -2 closer than min, -3 farther than max.
Move:
  Dir(LEFT) = Arg.BIT7       'Direction of motion given by sign bit of Arg.
  Dir(RIGHT) = Dir(LEFT)     'Both directions are the same.

  PUT SP, ARG                'Save the distance in a word for trig.
  SP = SP + 1

  Arg = ABS(Arg << 8) >> 8   'Take the absolute value of Arg to get distance.
                             'Compute length of first leg of tack.
  Dist(LEFT) = Arg * (16 - (ABS(DirErr) / (BRDSPER >> 4))) / 16
  IF (Dist(LEFT)) THEN       'Is it greater than zero?
    Dist(RIGHT) = Dist(LEFT) '  Yes: Right wheel goes the same distance.
    GOSUB DoMove             '       Execute the move
    Arg = Arg - Dist(LEFT)   '       Subtract the distance moved from Arg.
    IF (Arg) THEN            '       Anything left?
      Dist(LEFT) = DirErr.BIT15     '  Yes: Correct direction by the sign of DirErr.
      Dist(RIGHT) = Dist(LEFT) ^ 1  '       Only one wheel moves forward.
      GOSUB DoMove                  '       Execute the move.
    ENDIF
  ENDIF
  IF (Arg) THEN              'Now back to Arg. Is it greater than zero?
    Dist(RIGHT) = Arg        '  Yes: Set distances from it.
    Dist(LEFT) = Arg
    GOSUB DoMove             '       Execute this leg of the move.
  ENDIF

  ' Use trig to calculate the new XY position.
  ' TODO - I need to handle the interrupted move case.
  SP = SP - 1
  GET SP, Y
  ' Fall through to x y update code.

' UpdatePosXY - uses integer trig functions to compute a new X,Y position
' from the current position coupled with a vector magniture and direction.
' Inputs:
'   Y.LOWBYTE - the vector magnitude.
'   Theta - the polar direction the robot is moving.
' Outputs:
'   Position(XPOS,YPOS) - the new X,Y position.
UpdatePosXY:
  ' Compute the X component of the vector.
  Z = Y.LOWBYTE * COS Theta
  ' Rescale the vector X component and recompute x pos.
  IF (Z.BIT15 = 1) THEN
    Z = ABS(Z) / 127
    Position(XPOS) = Position(XPOS) - Z
  ELSE
    Z = Z / 127
    Position(XPOS) = Position(XPOS) + Z
  ENDIF

  ' Compute the Y component of the vector to y pos.
  Z = Y.LOWBYTE * SIN Theta

  ' Rescale the vector Y component and recompute y pos.
  IF (Z.BIT15 = 1) THEN
    Z = ABS(Z) / 127
    Position(YPOS) = Position(YPOS) - Z
  ELSE
    Z = Z / 127
    Position(YPOS) = Position(YPOS) + Z
  ENDIF
  RETURN

' MoveXY - calculate a vector to a specific location.  Turn in that direction,
'   and move that amount.
' Inputs:
'   X - the X coordinate to go to.
'   Y - the Y coordinate to go to.
'   Z - distance constraint (low byte min, top byte max) zero = none.
' Outputs:
MoveXY:
  ' Compute the X and Y components of a vector to the destination.
  ACC = Position(XPOS)
  GOSUB SignExtendAcc
  X = X - ACC
  ACC = Position(YPOS)
  GOSUB SignExtendAcc
  Y = Y - ACC

  ACC = X HYP Y                               ' Compute the distance
  PUT SP, ACC                                 ' save in scratch
  SP = SP + 1

  ACC = X ATN Y                               ' Compute the polar vector angle
  DEBUG "ACC = ", SDEC ACC, CR
  Arg = ACC.LOWBYTE - Theta                   ' Compute the delta from theta
  Veloc = 15
  GOSUB Turn                                  ' and turn that direction.
  SP = SP - 1                                 ' Fetch the distance from scratch.
  GET SP, Arg
  Veloc = 15
  GOSUB Move                                  ' Move that amount
  RETURN

' Turn the robot on its axis by the amount in signed byte Arg at speed Veloc.
' Inputs:
'   Arg - number of brads to turn. > 0 turns left; Arg < 0 turns right.
'   Veloc - peak speed where 0 is stop and 15 is fast.
'   Z - distance constraint (low byte min, top byte max) zero = none.
' Outputs:
'   X - 0 success, -1 stall, -2 closer than min, -3 farther than max.
Turn:
  Theta = Theta + Arg                         'Update computed heading.
  DirErr = DirErr + (Arg << 8)                'Adjust direction error by amount of turn.
  Arg = ABS(DirErr) ** FULLROT >> 7 + 1 >> 1  'Compute new Arg from new DirErr.
  Dir(RIGHT) = DirErr.BIT15                   'Direction of turn is sign bit of DirrErr.
  Arg = ABS(Arg << 8) >> 8                    'Amount of turn is absolute value of Arg.
  Dist(LEFT) = Arg >> 1                       'Split turn amount evenly between both wheels.
  Dist(RIGHT) = Arg >> 1 + (Arg.BIT0)         'Round right wheel up if Arg is odd.
  Dir(LEFT) = ~ Dir(RIGHT)                    'Left wheel goes opposite direction.
  GOTO DoMove                                 'Execute the motion.

' TurnCompass - Turns the robot to align with a specific compass heading.
' Inputs:
'   Arg - the compass heading to match.
' Outputs:
'   Heading
TurnCompass:
  Arg = Heading - Arg                   ' Compute the compass delta.
  Veloc = 15                            ' Max speed
  MinDistance = 0                       ' Inplace turns have no constraints
  MaxDistance = 0
  GOSUB Turn
  ACC = Heading                         ' Synchronize theta with the compass
  GOSUB ToPolarACC
  Theta = ACC.LOWBYTE
  RETURN

' TurnRight - turns using the right wheel as the center of rotation.
' Inputs:
'   Arg - number of brads to turn. > 0 turns left; Arg < 0 turns right.
'   Veloc - peak speed where 0 is stop and 15 is fast.
'   Z - distance constraint (low byte min, top byte max) zero = none.
' Outputs:
'   X - 0 success, -1 stall, -2 closer than min, -3 farther than max.
TurnRight:
  Dist(RIGHT) = 0                             ' Right wheel stays still.
  Dist(LEFT) = Arg                            ' while the left wheel moves.
  Dir(LEFT) = Arg.BIT7                        ' Motion direction given by sign bit of Arg.
  Dir(RIGHT) = Dir(LEFT)                      ' Both directions are the same.
  GOTO DoMove                                 ' Execute the move.

' Left - turns using the left wheel as the center of rotation.
' Inputs:
'   Arg - number of brads to turn. > 0 turns left; Arg < 0 turns right.
'   Veloc - peak speed where 0 is stop and 15 is fast.
'   Z - distance constraint (low byte min, top byte max) zero = none.
' Outputs:
'   X - 0 success, -1 stall, -2 closer than min, -3 farther than max.
TurnLeft:
  Dist(LEFT) = 0                              ' Left wheel stays still.
  Dist(RIGHT) = Arg                           ' while the right wheel moved.
  Dir(LEFT) = Arg.BIT7                        ' Motion direction given by sign bit of Arg.
  Dir(RIGHT) = Dir(LEFT)                      ' Both directions are the same.
  GOTO DoMove                                 ' Execute the move.

' DoMove - Move the wheels the amount specified in Dist array.
' Inputs:
'   Dist - signed distance to move wheels.
'   Veloc - peak velocity.
' Outputs:
'   X - 0 success, -1 stall, -2 closer than min, -3 farther than max.
DoMove:
  'Correct DirErr by effects of presumptive motion.
  'Initialize Counts TO Dist.
  'Save current encoder status.

  FOR Side = RIGHT TO LEFT
    DirErr = DirErr + ((Side ^ Dir(Side) << 1 - 1) * Dist(Side) * BRDSPER)
    Counts(Side) = Dist(Side)
    Prev(Side) = INS.LOWBIT(Sense + Side)
    PAUSE 1000
  NEXT

  'Do for as long as there are encoder counts remaining...

  DO WHILE (Counts(RIGHT) OR Counts(LEFT))

    'Get new encoder state for each wheel.
    'If it's changed, decrement that wheel's Count.

    FOR Side = RIGHT TO LEFT
      New(Side) = INS.LOWBIT(Sense + Side)
      IF (New(Side) <> Prev(Side) AND Counts(Side)) THEN
        Prev(Side) = New(Side)
        Counts(Side) = Counts(Side) - 1
      ENDIF
    NEXT

    'For each wheel decide whether and how much to pulse its servo.

    FOR Side = RIGHT TO LEFT
      Opp = ~ Side
      IF (Counts(Side) AND Counts(Side) * Dist(Opp) + (Dist(Side)) >= Counts(Opp) * Dist(Side) + (Dist(Opp) >> 1)) THEN
        Pulse = (Veloc MIN 3) MAX ((Counts(Side) MIN Counts(Opp)) MAX ((Dist(Side) - Counts(Side)) MIN (Dist(Opp) - Counts(Opp))) << 1 MIN 3)
        READ Side << 1 + (Dir(Side) ^ Side) << 4 + (Pulse * Dist(Side) / (Dist(Side) MIN Dist(Opp)) + 1 MAX 15), Pulse
        PULSOUT Motor + Side, NULL - ((Dir(Side) ^ Opp << 1 - 1) * Pulse)
      ENDIF
    NEXT

    'Pause between pulses.

    PAUSE 5

    IF (Z <> 0) THEN                          ' Z indicates a distance constraint.
      GOSUB PingDistance                      ' Then ping to get distance in X
      IF (MinDistance <> 0 AND X < MinDistance) THEN
        X = ErrorTooClose                     ' discard X, set error, and return.
        GOTO CompassFinally
      ELSEIF (MaxDistance <> 0 AND X > MaxDistance) THEN
        X = ErrorTooFar                       ' discard X, set error, and return.
        GOTO CompassFinally
      ENDIF
    ENDIF
  LOOP
  X = Success
CompassFinally:
  GOSUB ReadCompass                           ' After a move re-read the compass
  RETURN

' SignExtendACC - converts a signed byte in ACC into a signed word.
' Inputs:
'   ACC.LOWBYTE - the 8 bit value
' Outputs:
'   ACC - the 16 bit signed quantity.
SignExtendACC:
  ACC.HIGHBYTE = 0
  IF (ACC.BIT7 = 1) THEN
    ACC = ACC | NegMask8
  ELSE
    ACC = ACC
  ENDIF
  RETURN

' ToCompassAcc, ToPolarAcc - converts a compass heading in ACC into a
'  polar heading, and vice versa.  Two labels are used simply to make
'  the conversion more self documenting.
' Inputs:
'   ACC.LOWBYTE - the 8 bit value heading
' Outputs:
'   ACC - the 16 bit signed quantity.
ToCompassAcc:
ToPolarAcc:
  GOSUB SignExtendAcc
  ACC = - ACC + 64                            ' Convert to a polar offset
  GOSUB SignExtendAcc
  RETURN

' Stop - pulse out stop signal to stop initial lurch and prevent over steering.
' Inputs:
' Outputs:
StopIt:
  PULSOUT RMotor, NULL
  PULSOUT LMotor, NULL
  PAUSE 15
  RETURN

' Unimplemented code here.

' CheckStall - determines if the wheels are stalled by checking encoder state variables.
' Inputs:
'   LCount - current value of left wheel count.
'   RCount - current value of right wheel count.
'   LastLRSum - prior sum of the two values.
' Outputs:
'   SP - 0 no stall, 1 stall.
CheckStall:
  ' If enough pulses have elapsed.
  ' Is the sum of LCount and RCount greater than LastLRSum?
  '  Yes - push 0
  '  No - push 1
  RETURN

' ReadBarcode - reads a barcode and returns the bits in X.
' Inputs:
' Outputs:
'   X - positive value of barcode or -1 no barcode detected.
ReadBarcode:
  ' Read LFM
  ' IF (left center or right center = 0) THEN NoBars
  ' DO WHILE (LineRight)
  ' LOOP
  '   PULSIN LineRight, 1, ScrW1
  '   IF (ScrW1 = 0) THEN NoBars
  '   PULSIN LineRight, 1, ScrW0
  '   IF (ScrW0 = 0) THEN NoBars
  '   ScrB3 = (ScrW0 >> 1) + (ScrW1 >> 1) >> 8
  '   FOR ScrB2 = 1 TO 5
  '     IF (ScrB2 <= 4) THEN
  '       LineCount = LineCount << 1
  '       IF (ScrW0.HIGHBYTE > ScrB3) THEN LineCount.LOWBIT = 1
  '     ENDIF
  '     PULSIN LineRight, 1, ScrW0
  '     IF (ScrW0 = 0) THEN NoBars
  '   NEXT
  '   IF (LineCount.BIT3) THEN LineCount = LineCount REV 3 | 8
  '   GOTO LineDisable
NoBars:
  ' Linecount = 0
LineDisable:
  ' LOW LineEnable
  X = -1                                      ' Clear the last reading
  RETURN